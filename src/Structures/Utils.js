import bcrypt from 'bcrypt';
import crypto from 'crypto';
import User from '../Schemas/User';
import VerifyingUser from '../Schemas/VerifyingUser';
import { promisify } from 'util';

const sleep = promisify(setTimeout);

class Utils {
    constructor() {
        this.saltRounds = 10;
        this.byteSize = 48;
    }

    toString() {
        return '[Evolve-X Utils]';
    }

    /**
     * Returns a random number between min (inclusive) and max (exclusive)
     */
    genRandomNum() {
        return Math.random() * (9);
    }

    async sleep(ms) {
        await sleep(ms);
        return Promise.resolve();
    }

    genUID() {
        const max = 22;
        const min = 18;
        const wut = 1;
        const num = Math.floor(Math.random() * (max - min + wut) ) + min;
        let uID = '';
        const maxChar = 9;
        const minChar = 1;
        for (let i = 0; i < num; i++) {
            uID += String(Math.floor(Math.random() * (maxChar - minChar + wut) ) + minChar);
        }
        return Promise.resolve(uID);
    }

    hashPass(password) {
        const minPass = 8;
        const maxPass = 32;
        if (password.length < minPass || password.match(/[A-Za-z0-9_.&]/g).length !== password.length) {
            throw Error('Password must be 8 characters or more long, and be only contain alphanumeric characters as well as `.`, and `&`');
        }
        if (password.length > maxPass) {
            throw Error('Password is too long, password must be under 32 characters long');
        }
        return bcrypt.hash(password, this.saltRounds);
    }

    async genNotifyID(notifs) {
        const ID = await this.genUID();
        const notify = notifs.find(notif => notif.id === ID);
        if (notify) {
            return this.genNotifyID();
        }
        return ID;
    }

    async genToken(userID) {
        const random = crypto.randomBytes(this.byteSize).toString('base64')
            .replace(/[+\\]/, '-')
            .replace(/[=/.]/, '_');
        const uID = new Buffer.from(userID).toString('base64');
        const date = Buffer.from(new Date().getUTCMilliseconds().toString() ).toString('base64');
        const token = `${uID}.${random}.${date}`;
        const hash = await bcrypt.hash(token, this.saltRounds);
        return { token, hash };
    }

    async validateToken(token) {
        token = await bcrypt.hash(token, this.saltRounds);
        const user = await VerifyingUser.findOne( { validationToken: token } );
        if (user) {
            return { success: true, uID: user.uID };
        }
        return { success: false };
    }

    async verify(userID, asAdmin) {
        // Get the old verifying user info and make sure it exists
        const oUser = await VerifyingUser.findOne( { uID: userID } );
        if (!oUser) {
            throw Error(`[ERROR] - [Utils.verify] - User ${userID} not found!`);
        }
        // Delete the user and make sure that went ok
        const vUser = await VerifyingUser.findOneAndRemove( { uID: userID } );
        if (vUser.n !== 1) { //  If it cannot delete the user
            throw Error('[Unknown Error] - [Utils.verify] - removing pending status fail');
        }

        // Make the users account
        const user = new User( {
            uID: userID, admin: asAdmin, email: oUser.email, username: oUser.username, password: oUser.password,
        } ); // Token will be generated by user
        await user.save();
        return user;
    }

    async genValidationToken() {
        const random = crypto.randomBytes(this.byteSize).toString('base64')
            .replace(/[+\\]/, '-')
            .replace(/[=/.]/, '_');
        const randomID = crypto.randomBytes(this.byteSize).toString('base64')
            .replace(/[+\\]/, '-')
            .replace(/[=/.]/, '_');
        const uID = new Buffer.from(randomID).toString('base64');
        const date = Buffer.from(new Date().getUTCMilliseconds().toString() ).toString('base64');
        const token = `${random}.${uID}.${date}`;
        const hash = await bcrypt.hash(token, this.saltRounds);
        return { token, hash };
    }

    async authToken(token, userID) {
        const user = await User.findOne( { uID: userID } );
        if (!user) {
            return;
        }
        if (!bcrypt.compareSync(token, user.token) ) {
            return;
        }
        return user;
    }


    async authPassword(password, userID) {
        const user = await User.findOne( { uID: userID } );
        if (!user) {
            return;
        }
        if (!bcrypt.compareSync(password, user.password) ) {
            return;
        }
        return user;
    }

    async findVerifying(validationToken, userID) {
        const user = await VerifyingUser.findOne( { uID: userID } );
        if (!user) {
            return;
        }
        if (!bcrypt.compareSync(validationToken, user.validationToken) ) {
            return;
        }
        return user;
    }
}

export default Utils;
